<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>多條函數線方程比對視覺化（加速＋可見性修正版）</title>
  <style>
    :root { --controls-h: 3.25rem; }
    body {
      margin: 0;
      background: #0b1020;
      color: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
      overflow: hidden;
    }
    /* 置頂控制列（可調參數 + 常用切換） */
    #controls {
      position: fixed; top: 0; left: 0; right: 0;
      display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;
      padding: 0.5rem 0.5rem; background: #111827; border-bottom: 1px solid #374151; z-index: 20;
    }
    #controls h1 { margin: 0; font-size: 1.05rem; color: #60a5fa; white-space: nowrap; }
    #controls label { display: flex; align-items: center; gap: 0.25rem; font-size: 0.85rem; white-space: nowrap; }
    #controls input[type="file"]{ color:#e5e7eb; background:#1f2937; border:1px solid #374151; padding:0.25rem; }
    #controls select, #controls button, #controls input[type="checkbox"]{
      background:#1f2937; color:#e5e7eb; border:1px solid #374151; padding:0.25rem 0.5rem; border-radius:4px; font-size:0.85rem; cursor:pointer; min-width:70px;
    }
    #controls button:hover { background:#374151; }

    /* 參數列（移出設定面板，避免遮擋） */
    #paramBar { display:flex; align-items:center; gap:0.5rem; overflow-x:auto; max-width:100%; padding:0.25rem 0; }
    .param { display:inline-flex; align-items:center; gap:0.25rem; background:#0f172a; border:1px solid #334155; border-radius:6px; padding:0.25rem 0.5rem; white-space:nowrap; }
    .param label { font-size:0.75rem; color:#9ca3af; }
    .param input[type="range"] { width: 140px; }
    .param input[type="number"] { width:80px; background:#111827; border:1px solid #374151; color:#e5e7eb; font-size:0.8rem; }

    /* 設定面板（僅保留篩選與方程） */
    #settingsPanel { position:fixed; top:var(--controls-h); right:0; width:340px; max-height:calc(100vh - var(--controls-h)); overflow-y:auto; background:#1f2937; border-left:1px solid #374151; padding:0.75rem; transform:translateX(100%); transition:transform 0.25s ease-in-out; z-index:15; }
    #settingsPanel.open { transform: translateX(0); }
    #settingsPanel h2 { margin:0 0 0.5rem 0; font-size:1rem; color:#60a5fa; }
    .section { margin-bottom:1rem; }
    .section label { display:block; margin-bottom:0.25rem; font-size:0.8rem; color:#9ca3af; }
    .section input[type="range"] { width:100%; }
    .section textarea { width:100%; min-height:120px; background:#111827; color:#e5e7eb; border:1px solid #374151; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:0.8rem; }

    /* 繪圖區：頂端高度自動對齊控制列 */
    #chartContainer { position:absolute; top:var(--controls-h); bottom:0; left:0; right:0; overflow:hidden; }
    #chartCanvas { width:100%; height:100%; display:block; }

    #legend { position:fixed; bottom:0.5rem; left:0.5rem; background:rgba(15,23,42,0.9); padding:0.5rem; border-radius:6px; font-size:0.75rem; max-width:44%; max-height:38vh; overflow-y:auto; border:1px solid #334155; }
    #legend .row { display:flex; align-items:center; margin-bottom:0.25rem; gap:0.25rem; }

    #message { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#9ca3af; font-size:1rem; text-align:center; white-space:pre-wrap; }

    .bulk { margin:0.25rem 0 0.5rem; display:flex; gap:0.25rem; flex-wrap:wrap; }
    .bulk button { padding:0.15rem 0.5rem; font-size:0.75rem; }
  </style>
</head>
<body>
  <div id="controls">
    <h1>多函數線方程比對（加速版）</h1>
    <label>CSV<input type="file" id="csvFile" accept=".csv" /></label>
    <label>TXT<input type="file" id="txtFile" accept=".txt" /></label>
    <button id="exampleA" title="載入範例 A">示例 A</button>
    <button id="exampleB" title="載入範例 B">示例 B</button>
    <label>X 軸<select id="xSelect"></select></label>
    <label style="display:inline-flex;align-items:center;gap:0.25rem"><input type="checkbox" id="lockAxes" checked />鎖定座標</label>
    <label style="display:inline-flex;align-items:center;gap:0.25rem" title="將函數值的 5–95% 分位數也納入座標計算，避免函數完全跑出畫面"><input type="checkbox" id="includeFuncQuantiles" checked />函數入軸(5–95%)</label>
    <button id="resetParams">重設參數</button>
    <button id="toggleSettings">設定</button>
    <!-- 參數列（會即時更新） -->
    <div id="paramBar"></div>
  </div>

  <div id="settingsPanel">
    <h2>設定</h2>
    <div id="filterSection" class="section"></div>
    <div id="equationSection" class="section">
      <label for="equationInput">方程式編輯（必須包含 eq=...）</label>
      <textarea id="equationInput"></textarea>
      <button id="applyEquation">套用方程</button>
    </div>
  </div>

  <div id="chartContainer">
    <canvas id="chartCanvas"></canvas>
    <div id="message"></div>
    <div id="legend"></div>
  </div>

  <script>
  // -------------------- 範例資料 --------------------
  const exampleAData = `v1,v2,v3,v4,value\n0.1,0,0,31.403935408357594,-7.2987317818\n0.10816326530612246,1,1,28.772030269246407,-6.613613395\n0.1163265306122449,1,1,39.767476761184525,-7.3951259572\n0.12448979591836735,0,1,22.04089621496056,-7.7764767558\n0.1326530612244898,1,1,24.177535121896696,-6.5779052811\n0.14081632653061227,1,0,23.226190357699924,-7.1279443218\n0.1489795918367347,1,1,33.06216650930797,-7.1546304445\n0.15714285714285714,1,0,25.065832050795642,-7.1213832017\n0.1653061224489796,1,0,29.326215457126125,-6.5347771428\n0.17346938775510207,1,1,24.888511840032056,-7.7606183393\n0.1816326530612245,1,1,23.179391672910395,-6.9111706361\n0.18979591836734694,0,0,22.207502823286102,-7.5819665698\n0.1979591836734694,0,1,33.126591789305465,-7.3351251825\n0.20612244897959187,1,0,22.763659026972277,-7.3661679895\n0.2142857142857143,0,1,23.93164723360107,-9.3193661316\n0.22244897959183674,0,0,27.37450341321928,-9.2863991758\n0.2306122448979592,0,0,36.4198645969587,-11.2623709618\n0.23877551020408164,0,0,21.942025515861225,-11.2755564387\n0.2469387755102041,0,0,36.758898149976076,-12.8287491264\n0.2551020408163266,1,0,21.921968157879263,-12.9729740121\n0.263265306122449,0,1,39.529189300267916,-13.7109643688\n0.27142857142857146,1,1,29.37302403295403,-13.5832634594\n0.2795918367346939,1,0,39.535221763806746,-15.6620129919\n0.28775510204081634,0,0,32.09691039490092,-15.1294884383\n0.29591836734693877,0,0,34.78527158796604,-14.8274359553\n0.3040816326530612,1,1,20.783755845086414,-15.8166307749\n0.3122448979591837,1,1,25.65613925152819,-13.7952339417\n0.3204081632653062,1,0,22.403931224263378,-15.0075354341\n0.3285714285714286,1,1,25.922803950442898,-16.5247671101\n0.33673469387755106,0,0,22.37455437908488,-15.2514506557\n0.3448979591836735,1,0,26.35966358787952,-16.6600609391\n0.35306122448979593,0,1,28.2852598902934,-16.056000484\n0.36122448979591837,1,0,21.282949926975686,-15.0229669014\n0.3693877551020408,0,1,33.8494423874004,-15.7826875702\n0.37755102040816324,1,1,31.332029084131502,-16.9831674474\n0.3857142857142858,1,1,25.30778981878891,-17.1815368913\n0.3938775510204082,0,1,30.464961069333995,-17.2241404304\n0.40204081632653066,1,1,21.878810215168834,-17.625059345\n0.4102040816326531,1,1,31.518929911123585,-17.6205813416\n0.41836734693877553,0,0,38.58592395152428,-16.7201872166\n0.42653061224489797,0,1,26.371379049026473,-18.6179101111\n0.4346938775510204,1,1,33.348207599273636,-16.4596524298\n0.44285714285714284,0,0,22.635957248087845,-16.7383288951\n0.4510204081632654,1,0,34.32654408237131,-18.5990472885\n0.4591836734693878,1,1,25.788121858944024,-18.2492714753\n0.46734693877551026,1,0,23.663827240142336,-17.8318654208\n0.4755102040816327,1,0,31.730258696201663,-15.3689257002\n0.48367346938775513,1,1,20.402150923749872,-18.7114890641\n0.49183673469387756,0,1,36.57880058434726,-17.8741045022\n0.5,1,0,20.09390952385094,-19.0352957868`;
  const exampleAEq = `[PARAMS]\na = 5\nb = 2\nc = -7\n\n[EQUATION]\naa = inv(clamp(v1, 0.2, 0.3)) - inv(0.2)\nbb = inv(clamp(v1, 0.3, 0.4)) - inv(0.3)\neq = c + b*bb + a*aa`;
  const exampleBData = `v1,v2,v3,v4,value\n1,1,1,10,6\n2,1,1,10,7\n3,1,1,10,8\n4,1,1,10,9\n1,2,1,10,8\n2,2,1,10,9\n3,2,1,10,10\n4,2,1,10,11`;
  const exampleBEq = `[PARAMS]\na = 1\nb = 2\nc = 3\n\n[EQUATION]\neq = c + b*v2 + a*v1`;

  // -------------------- 色彩與形狀（穩定且可重現） --------------------
  function hashString(str){ let h=0x811c9dc5>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h+((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)))>>>0; } return h>>>0; }
  function hslToHex(h,s,l){ s/=100; l/=100; const c=(1-Math.abs(2*l-1))*s; const x=c*(1-Math.abs((h/60)%2-1)); const m=l-c/2; let r=0,g=0,b=0; if(0<=h&&h<60){r=c;g=x;b=0;} else if(60<=h&&h<120){r=x;g=c;b=0;} else if(120<=h&&h<180){r=0;g=c;b=x;} else if(180<=h&&h<240){r=0;g=x;b=c;} else if(240<=h&&h<300){r=x;g=0;b=c;} else {r=c;g=0;b=x;} r=Math.round((r+m)*255); g=Math.round((g+m)*255); b=Math.round((b+m)*255); return '#' + r.toString(16).padStart(2,'0') + g.toString(16).padStart(2,'0') + b.toString(16).padStart(2,'0'); }
  function colorForKey(key){ const h=hashString(key)%360; return hslToHex(h,58,62); }
  function shapeForKey(key){ const shapes=['circle','square','triangle','diamond']; return shapes[hashString(key)%shapes.length]; }

  // -------------------- 數學工具 --------------------
  function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
  function inv(z){ return 1 / z; }
  function normsInv(p){ if(p<=0||p>=1) return NaN; const a1=-3.969683028665376e+01,a2=2.209460984245205e+02,a3=-2.759285104469687e+02,a4=1.383577518672690e+02,a5=-3.066479806614716e+01,a6=2.506628277459239e+00; const b1=-5.447609879822406e+01,b2=1.615858368580409e+02,b3=-1.556989798598866e+02,b4=6.680131188771972e+01,b5=-1.328068155288572e+01; const c1=-7.784894002430293e-03,c2=-3.223964580411365e-01,c3=-2.400758277161838e+00,c4=-2.549732539343734e+00,c5=4.374664141464968e+00,c6=2.938163982698783e+00; const d1=7.784695709041462e-03,d2=3.224671290700398e-01,d3=2.445134137142996e+00,d4=3.754408661907416e+00; const pLow=0.02425,pHigh=1-pLow; let q,r,x; if(p<pLow){ q=Math.sqrt(-2*Math.log(p)); x=(((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6) / (((((d1*q+d2)*q+d3)*q+d4)*q)+1); } else if(p>pHigh){ q=Math.sqrt(-2*Math.log(1-p)); x=-(((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6) / (((((d1*q+d2)*q+d3)*q+d4)*q)+1); } else { q=p-0.5; r=q*q; x=(((((a1*r+a2)*r+a3)*r+a4)*r+a5)*r+a6)*q / (((((b1*r+b2)*r+b3)*r+b4)*r+b5)*r+1); } const e=0.5*erfc(-x/Math.SQRT2)-p; const u=e*Math.SQRT2*Math.exp(x*x/2); x=x - u/(1 + x*u/2); return x; }
  function erfc(x){ return 1 - erf(x); }
  function erf(x){ const sign=Math.sign(x); x=Math.abs(x); const t=1/(1+0.3275911*x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429; const poly=((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t; const y=1 - poly*Math.exp(-x*x); return sign*y; }

  // -------------------- DOM 與全域狀態 --------------------
  function sanitizeName(name){ return name.trim().replace(/[^a-zA-Z0-9_]/g,'_').replace(/^([0-9])/, '_$1'); }

  let csvRows = [];        // 原始資料列
  let colNames = [];       // 前四欄變數名
  let valueKey = 'value';  // 目標值欄位名
  let params = {};         // 參數（可調）
  let assignments = [];    // 方程前置變數 {var, expr}
  let eqAssign = null;     // {var:'eq', expr}
  let filterSelections = {}; // 每個變數對應 Set
  let xVar = null;
  let axesCache = null;    // {xMin,xMax,yMin,yMax}
  let combosCache = null;  // 結構化的分組緩存（資料點固定）

  const controls = document.getElementById('controls');
  const paramBar = document.getElementById('paramBar');
  const xSelect = document.getElementById('xSelect');
  const filterSection = document.getElementById('filterSection');
  const equationInput = document.getElementById('equationInput');
  const settingsPanel = document.getElementById('settingsPanel');
  const toggleSettingsBtn = document.getElementById('toggleSettings');
  const lockAxesChk = document.getElementById('lockAxes');
  const includeFuncQuantilesChk = document.getElementById('includeFuncQuantiles');
  const resetParamsBtn = document.getElementById('resetParams');
  const messageDiv = document.getElementById('message');
  const legendDiv = document.getElementById('legend');
  const chartCanvas = document.getElementById('chartCanvas');
  const ctx = chartCanvas.getContext('2d');

  // 控制：開關設定面板
  toggleSettingsBtn.addEventListener('click', () => settingsPanel.classList.toggle('open'));

  // 自動調整 chartContainer 頂端位移，避免控制列遮擋
  function updateControlsHeightVar(){ const h=controls.getBoundingClientRect().height; document.documentElement.style.setProperty('--controls-h', `${Math.round(h)}px`); }
  const resizeObserver = new ResizeObserver(updateControlsHeightVar); resizeObserver.observe(controls);

  // Canvas 尺寸
  function resizeCanvas(){ const container=document.getElementById('chartContainer'); chartCanvas.width=container.clientWidth; chartCanvas.height=container.clientHeight; scheduleUpdate('resize'); }
  window.addEventListener('resize', resizeCanvas);

  // -------------------- 解析與編譯（大幅提速） --------------------
  const helperMap = { clamp, inv, min:Math.min, max:Math.max, abs:Math.abs, sqrt:Math.sqrt, log:Math.log, LN:Math.log, ln:Math.log, exp:Math.exp, EXP:Math.exp, pow:Math.pow, NORMSINV:normsInv, normsInv:normsInv };
  const helperNames = Object.keys(helperMap);
  const compiled = { baseNames: [], assignFns: [], assignNames: [], assignVars: [], eqFn: null, eqNames: [] };

  function parseCSV(content){
    const lines = content.replace(/\r/g,'').trim().split(/\n+/);
    if (!lines.length) return [];
    let header = lines[0]; if (header.charCodeAt(0)===0xfeff) header = header.slice(1);
    const headers = header.split(',').map(h=>h.trim());
    const sanitized = headers.map(sanitizeName);
    const data = [];
    for (let i=1;i<lines.length;i++){
      const line = lines[i].trim(); if (!line) continue;
      const parts = line.split(','); if(parts.length < sanitized.length) continue;
      const row = {}; for (let j=0;j<sanitized.length;j++){ const val=parts[j].trim(); const num=Number(val); row[sanitized[j]] = (val===''||isNaN(num))? val : num; }
      data.push(row);
    }
    colNames = sanitized.slice(0,4); valueKey = sanitized[4] || 'value';
    return data;
  }

  function parseTXT(content){
    const lines = content.replace(/\r/g,'').split(/\n+/);
    params = {}; assignments=[]; eqAssign=null; let current=null;
    for (const raw of lines){ const line=raw.trim(); if(!line||line.startsWith('#')) continue; const lower=line.toLowerCase(); if(lower.startsWith('[params]')){ current='params'; continue;} if(lower.startsWith('[equation]')){ current='eq'; continue; }
      if(current==='params'){ const m=line.split('='); if(m.length>=2){ const key=sanitizeName(m[0].trim()); const val=parseFloat(m[1].replace(/\s+/g,'')); if(!Number.isNaN(val)) params[key]=val; } }
      else if(current==='eq'){ const m=line.split('='); if(m.length>=2){ const key=sanitizeName(m[0].trim()); const expr=m.slice(1).join('='); if(key==='eq') eqAssign={var:key, expr:expr.trim()}; else assignments.push({var:key, expr:expr.trim()}); } }
    }
  }

  function jsify(expr){ return String(expr).replace(/\^/g,'**'); }

  function unique(arr){ return Array.from(new Set(arr)); }

  function rebuildCompiled(){
    compiled.baseNames = unique([ ...Object.keys(params), ...colNames, valueKey, ...helperNames ]);
    compiled.assignFns = []; compiled.assignNames = []; compiled.assignVars = [];
    // 依序編譯前置賦值，逐步擴充可用名稱
    let available = compiled.baseNames.slice();
    for (const a of assignments){
      const names = unique([...available]);
      const fn = new Function(...names, '"use strict"; return (' + jsify(a.expr) + ');');
      compiled.assignFns.push(fn); compiled.assignNames.push(names); compiled.assignVars.push(a.var);
      available.push(a.var);
    }
    if (eqAssign){
      const names = unique([...available]);
      compiled.eqFn = new Function(...names, '"use strict"; return (' + jsify(eqAssign.expr) + ');');
      compiled.eqNames = names;
    } else {
      compiled.eqFn = null; compiled.eqNames = [];
    }
  }

  function valuesByNames(names, row, locals){
    const out = new Array(names.length);
    for (let i=0;i<names.length;i++){
      const k = names[i];
      if (k in params) out[i] = params[k];
      else if (row && k in row) out[i] = row[k];
      else if (locals && k in locals) out[i] = locals[k];
      else if (k in helperMap) out[i] = helperMap[k];
      else if (k === undefined) out[i] = undefined;
      else out[i] = undefined;
    }
    return out;
  }

  function computeEq(row){
    if (!compiled.eqFn) return NaN;
    // 依序計算 assignments（使用同一 row / params）
    const locals = {};
    for (let i=0;i<compiled.assignFns.length;i++){
      const vals = valuesByNames(compiled.assignNames[i], row, locals);
      let v = NaN; try { v = compiled.assignFns[i](...vals); } catch(e){ v = NaN; }
      locals[compiled.assignVars[i]] = v;
    }
    const eqVals = valuesByNames(compiled.eqNames, row, locals);
    try { return compiled.eqFn(...eqVals); } catch(e){ return NaN; }
  }

  // -------------------- UI 建構 --------------------
  function buildParamControls(){
    paramBar.innerHTML = '';
    const schedule = () => scheduleUpdate('param');
    Object.keys(params).forEach(key => {
      const init = params[key];
      const range = Math.max(Math.abs(init) * 5, 10);
      const min = init - range; const max = init + range;
      const wrap = document.createElement('div'); wrap.className='param';
      const label = document.createElement('label'); label.textContent = `${key}`;
      const slider = document.createElement('input'); slider.type='range'; slider.min=min; slider.max=max; slider.step=(max-min)/100; slider.value=init;
      const number = document.createElement('input'); number.type='number'; number.min=min; number.max=max; number.step=slider.step; number.value=init;
      function commit(val){ const num=parseFloat(val); if(!Number.isFinite(num)) return; params[key]=num; slider.value=num; number.value=num; schedule(); }
      slider.addEventListener('input', () => commit(slider.value)); // rAF 節流
      number.addEventListener('change', () => commit(number.value));
      wrap.appendChild(label); wrap.appendChild(slider); wrap.appendChild(number);
      paramBar.appendChild(wrap);
    });
  }

  function buildFilters(){
    filterSection.innerHTML = '';
    if (!csvRows.length || !xVar) return;
    const vars = colNames.filter(v => v !== xVar);
    const fVars = vars.slice(0, 2);
    fVars.forEach(v => {
      const title = document.createElement('div'); title.textContent = `篩選 ${v}`; title.style.margin='0 0 0.25rem 0'; filterSection.appendChild(title);
      // 批次按鈕（全選 / 全不選）
      const bulk = document.createElement('div'); bulk.className='bulk';
      const bAll = document.createElement('button'); bAll.textContent='全選';
      const bNone = document.createElement('button'); bNone.textContent='全不選';
      bulk.appendChild(bAll); bulk.appendChild(bNone); filterSection.appendChild(bulk);

      const group = document.createElement('div'); group.style.display='flex'; group.style.flexWrap='wrap'; group.style.gap='0.25rem';
      const unique = Array.from(new Set(csvRows.map(r => r[v])));
      unique.sort((a,b)=>(!isNaN(a)&&!isNaN(b))? (parseFloat(a)-parseFloat(b)) : String(a).localeCompare(String(b)));
      const set = new Set(unique); filterSelections[v] = set;

      function renderChecks(){ group.innerHTML=''; unique.forEach(val => {
        const lb=document.createElement('label'); lb.style.display='inline-flex'; lb.style.alignItems='center'; lb.style.gap='0.25rem'; lb.style.fontSize='0.8rem';
        const cb=document.createElement('input'); cb.type='checkbox'; cb.checked = set.has(val);
        cb.addEventListener('change', () => { if(cb.checked) set.add(val); else set.delete(val); axesCache=null; scheduleUpdate('filter'); });
        lb.appendChild(cb); lb.appendChild(document.createTextNode(String(val))); group.appendChild(lb);
      }); }

      bAll.addEventListener('click', () => { unique.forEach(x=>set.add(x)); axesCache=null; renderChecks(); scheduleUpdate('filter'); });
      bNone.addEventListener('click', () => { set.clear(); axesCache=null; renderChecks(); scheduleUpdate('filter'); });

      renderChecks(); filterSection.appendChild(group);
    });
  }

  function populateXSelect(){
    xSelect.innerHTML=''; colNames.forEach(name=>{ const op=document.createElement('option'); op.value=name; op.textContent=name; xSelect.appendChild(op); });
    if (colNames.length){ xSelect.value = colNames[0]; xVar = colNames[0]; }
    xSelect.addEventListener('change', () => { xVar=xSelect.value; combosCache=null; axesCache=null; buildFilters(); scheduleUpdate('xchange'); });
  }

  // -------------------- 繪圖元件 --------------------
  function drawShape(ctx, shape, x, y, size, fill, stroke){
    ctx.save(); ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=1.2; ctx.beginPath();
    if (shape==='circle'){ ctx.arc(x,y,size,0,Math.PI*2); }
    else if (shape==='square'){ ctx.rect(x-size, y-size, size*2, size*2); }
    else if (shape==='triangle'){ ctx.moveTo(x, y-size); ctx.lineTo(x+size, y+size); ctx.lineTo(x-size, y+size); ctx.closePath(); }
    else if (shape==='diamond'){ ctx.moveTo(x, y-size); ctx.lineTo(x+size, y); ctx.lineTo(x, y+size); ctx.lineTo(x-size, y); ctx.closePath(); }
    else { ctx.arc(x,y,size,0,Math.PI*2); }
    ctx.fill(); ctx.stroke(); ctx.restore();
  }

  // 分組建立（只在資料/篩選/X 改變時重算）
  function buildCombosStructure(){
    const combos = {};
    const vars = colNames.filter(v => v !== xVar);
    const fVars = vars.slice(0,2);
    const selectedMap = {}; fVars.forEach(v => { selectedMap[v] = filterSelections[v] ? new Set(filterSelections[v]) : null; });

    for (const row of csvRows){
      // 篩選：若集合為 null 表示未建立；若 size==0 代表「全不選」→ 直接排除
      let pass = true;
      for (const v of fVars){ const sel = selectedMap[v]; if (sel){ if (sel.size === 0){ pass=false; break; } if (!sel.has(row[v])){ pass=false; break; } } }
      if (!pass) continue;
      const key = fVars.map(v => row[v]).join('|');
      if (!combos[key]) combos[key] = { rows: [], points: [], line: [], color: colorForKey(key), shape: shapeForKey(key), label: '' };
      combos[key].rows.push(row);
    }

    // 標籤與點集（固定資料點與排序；eqY 會在之後每次更新）
    for (const key in combos){
      const combo = combos[key];
      const values = key.split('|'); const fVars2 = colNames.filter(v => v !== xVar).slice(0,2);
      combo.label = fVars2.map((v,i)=> `${v}=${values[i]}`).join(' & ');
      combo.points = combo.rows.map(row => ({ x: row[xVar], dataY: row[valueKey], eqY: NaN, diffCat: 'na', shape: combo.shape }));
      combo.points.sort((a,b)=> a.x - b.x);
    }

    return combos;
  }

  function quantile(arr, q){ if(!arr.length) return NaN; const a=arr.slice().sort((x,y)=>x-y); const pos=(a.length-1)*q; const lo=Math.floor(pos), hi=Math.ceil(pos); if(lo===hi) return a[lo]; const h=pos-lo; return a[lo]*(1-h)+a[hi]*h; }

  // 主繪圖流程（經節流）
  function drawChart(combos){
    ctx.clearRect(0,0,chartCanvas.width, chartCanvas.height);
    if (!combos || Object.keys(combos).length===0){ messageDiv.style.display='block'; messageDiv.textContent='尚未載入資料或無符合篩選的資料列'; legendDiv.innerHTML=''; return; }
    messageDiv.style.display='none';

    // 基於資料點計算座標（必要時合併函數分位）
    let xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity;
    const needAxes = !axesCache; if (axesCache){ ({xMin,xMax,yMin,yMax} = axesCache); }
    else {
      for (const key in combos){ const c=combos[key]; c.points.forEach(pt=>{ const xv=pt.x, dv=pt.dataY; if(Number.isFinite(xv)){xMin=Math.min(xMin,xv); xMax=Math.max(xMax,xv);} if(Number.isFinite(dv)){yMin=Math.min(yMin,dv); yMax=Math.max(yMax,dv);} }); }
      if (xMin===xMax){ xMin-=0.5; xMax+=0.5; }
      if (yMin===yMax){ yMin-=0.5; yMax+=0.5; }
      const xPad=(xMax-xMin)*0.08, yPad=(yMax-yMin)*0.12; xMin-=xPad; xMax+=xPad; yMin-=yPad; yMax+=yPad;
      axesCache = {xMin,xMax,yMin,yMax};
    }

    const margin=54; const w=chartCanvas.width, h=chartCanvas.height;
    const xScale = v => margin + (v - xMin) / (xMax - xMin) * (w - 2*margin);
    const yScale = v => h - margin - (v - yMin) / (yMax - yMin) * (h - 2*margin);

    // 按畫面寬度自適應取樣密度（提速）
    const samples = Math.min(600, Math.max(60, Math.floor(w / 2)));

    // 先生成各組連續函數（用於可選的分位入軸計算）
    let allLineY = [];
    for (const key in combos){
      const combo = combos[key]; const base = combo.rows[0] || {};
      // 以資料 x 範圍近似（如無 points 則跳過）
      let dXmin=Infinity, dXmax=-Infinity; combo.points.forEach(p=>{ if(Number.isFinite(p.x)){ dXmin=Math.min(dXmin,p.x); dXmax=Math.max(dXmax,p.x);} });
      if (!Number.isFinite(dXmin) || dXmin===dXmax){ dXmin = xMin; dXmax = xMax; }
      const step=(dXmax - dXmin)/(samples - 1);
      combo.line = [];
      for (let i=0;i<samples;i++){
        const xv = dXmin + step*i; const envRow = Object.assign({}, base); envRow[xVar] = xv; const yv = computeEq(envRow);
        combo.line.push({x:xv, y: yv}); if (Number.isFinite(yv)) allLineY.push(yv);
      }
    }

    // 若開啟「函數入軸(5–95%)」，以分位數擴增 y 範圍（避免極端值撐爆）
    if (includeFuncQuantilesChk.checked && allLineY.length){
      const q5 = quantile(allLineY, 0.05), q95 = quantile(allLineY, 0.95);
      const pad = (q95 - q5) * 0.12;
      const yLo = q5 - pad, yHi = q95 + pad;
      // 若原本座標不含此範圍，則擴展
      if (!(yLo >= yMin && yHi <= yMax)){
        yMin = Math.min(yMin, yLo); yMax = Math.max(yMax, yHi);
        axesCache = { xMin, xMax, yMin, yMax };
      }
    }

    // 座標軸
    ctx.strokeStyle='#334155'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(margin, h-margin); ctx.lineTo(w-margin, h-margin); ctx.moveTo(margin, margin); ctx.lineTo(margin, h-margin); ctx.stroke();
    ctx.fillStyle='#9ca3af'; ctx.font='12px system-ui, sans-serif';
    const xTicks=6, yTicks=6;
    for (let i=0;i<=xTicks;i++){ const xv=xMin + i*(xMax-xMin)/xTicks; const xp=xScale(xv); ctx.beginPath(); ctx.moveTo(xp, h-margin); ctx.lineTo(xp, h-margin+4); ctx.stroke(); const text=parseFloat(xv.toFixed(4)); const m=ctx.measureText(text); ctx.fillText(text, xp-m.width/2, h-margin+16); }
    for (let i=0;i<=yTicks;i++){ const yv=yMin + i*(yMax-yMin)/yTicks; const yp=yScale(yv); ctx.beginPath(); ctx.moveTo(margin-4, yp); ctx.lineTo(margin, yp); ctx.stroke(); const text=parseFloat(yv.toFixed(4)); const m=ctx.measureText(text); ctx.fillText(text, margin-m.width-6, yp+4); }

    // 重新計算每個資料點的 eq 與差異分類（快速路徑）
    for (const key in combos){
      const c = combos[key];
      c.points.forEach(pt => { const row = c.rows.find(r => r[xVar]===pt.x && r[valueKey]===pt.dataY) || c.rows[0]; const eqVal = computeEq(row); pt.eqY = eqVal; let diffCat='na'; if(Number.isFinite(eqVal)&&Number.isFinite(pt.dataY)&&pt.dataY!==0){ const diff=Math.abs(eqVal/pt.dataY - 1); if(diff<=0.05) diffCat='ok'; else if(diff<=0.10) diffCat='warn'; else diffCat='bad'; } pt.diffCat=diffCat; });
    }

    // 繪製
    for (const key in combos){
      const c = combos[key];
      // 曲線
      ctx.strokeStyle=c.color; ctx.lineWidth=2; ctx.beginPath(); let started=false;
      c.line.forEach(pt => { const xp=xScale(pt.x), yp=yScale(pt.y); if(!Number.isFinite(yp)) return; if(!started){ ctx.moveTo(xp, yp); started=true; } else { ctx.lineTo(xp, yp); } });
      ctx.stroke();

      // 每筆資料：資料點、函數點、連線
      c.points.forEach(pt => {
        const xp=xScale(pt.x); const ypData=yScale(pt.dataY); const ypEq=yScale(pt.eqY);
        // 垂直對應線
        if (Number.isFinite(ypEq)) { ctx.save(); ctx.strokeStyle=c.color+'80'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(xp, ypData); ctx.lineTo(xp, ypEq); ctx.stroke(); ctx.restore(); }
        // 函數值：空心
        if (Number.isFinite(ypEq)) { ctx.save(); ctx.fillStyle='#0b1020'; ctx.strokeStyle=c.color; drawShape(ctx, c.shape, xp, ypEq, 4.5, '#0b1020', c.color); ctx.restore(); }
        // 資料點：依差異分色，外框用組別色
        let fill; if(pt.diffCat==='ok') fill='#10b981'; else if(pt.diffCat==='warn') fill='#f59e0b'; else if(pt.diffCat==='bad') fill='#ef4444'; else fill='#94a3b8';
        drawShape(ctx, pt.shape, xp, ypData, 5.5, fill, c.color);
      });
    }

    // 圖例
    legendDiv.innerHTML='';
    const diffTitle=document.createElement('div'); diffTitle.className='row'; diffTitle.innerHTML='<strong>差異說明：</strong>'; legendDiv.appendChild(diffTitle);
    ;[{label:'≤5%', color:'#10b981'},{label:'5–10%', color:'#f59e0b'},{label:'≥10%', color:'#ef4444'},{label:'NA', color:'#94a3b8'}].forEach(dc=>{ const row=document.createElement('div'); row.className='row'; const sw=document.createElement('span'); sw.style.display='inline-block'; sw.style.width='12px'; sw.style.height='12px'; sw.style.background=dc.color; sw.style.borderRadius='2px'; row.appendChild(sw); const text=document.createElement('span'); text.textContent=dc.label; row.appendChild(text); legendDiv.appendChild(row); });
    const comboTitle=document.createElement('div'); comboTitle.className='row'; comboTitle.innerHTML='<strong>條件線：</strong>'; legendDiv.appendChild(comboTitle);
    Object.keys(combos).forEach(key=>{ const c=combos[key]; const row=document.createElement('div'); row.className='row'; const chip=document.createElement('span'); chip.style.display='inline-block'; chip.style.width='12px'; chip.style.height='12px'; chip.style.background=c.color; chip.style.borderRadius='2px'; row.appendChild(chip); const label=document.createElement('span'); label.textContent=c.label; row.appendChild(label); legendDiv.appendChild(row); });
  }

  // -------------------- 更新排程（rAF 節流） --------------------
  let rafId = 0, pendingReason = null;
  function scheduleUpdate(reason){
    // 將多次 input 合併成單次繪製；非 param 原因具有較高優先權
    if (pendingReason === 'param' && reason !== 'param') pendingReason = reason; else if (!pendingReason) pendingReason = reason;
    if (rafId) return;
    rafId = requestAnimationFrame(()=>{ const r = pendingReason || '未知'; pendingReason = null; rafId = 0; updatePlot({reason: r}); });
  }

  // -------------------- 主更新 --------------------
  function updatePlot(opts={}){
    const reason = opts.reason || 'unknown';
    legendDiv.innerHTML='';
    if (!csvRows.length){ messageDiv.style.display='block'; messageDiv.textContent='尚未載入資料'; ctx.clearRect(0,0,chartCanvas.width, chartCanvas.height); return; }
    if (!eqAssign){ messageDiv.style.display='block'; messageDiv.textContent='方程式未定義'; ctx.clearRect(0,0,chartCanvas.width, chartCanvas.height); return; }

    // 避免不必要的重建：只有資料/篩選/X 改變時才重建 combos 結構
    if (!combosCache || reason==='csv' || reason==='xchange' || reason==='filter' || reason==='exampleA' || reason==='exampleB' || reason==='resize'){
      combosCache = buildCombosStructure();
    }

    // 座標是否可更新
    if (reason !== 'param' || !lockAxesChk.checked || includeFuncQuantilesChk.checked){ axesCache = null; }

    drawChart(combosCache);
  }

  // -------------------- 檔案與按鈕事件 --------------------
  document.getElementById('csvFile').addEventListener('change', e => {
    const file = e.target.files[0]; if (!file) return;
    const reader = new FileReader(); reader.onload = ev => { try {
      csvRows = parseCSV(ev.target.result); if (!csvRows.length){ messageDiv.style.display='block'; messageDiv.textContent='CSV 檔案無有效資料列'; return; }
      populateXSelect(); buildFilters(); rebuildCompiled(); combosCache=null; axesCache=null; scheduleUpdate('csv');
    } catch(err){ messageDiv.style.display='block'; messageDiv.textContent='CSV 解析錯誤：'+String(err); } };
    reader.readAsText(file);
  });

  document.getElementById('txtFile').addEventListener('change', e => {
    const file = e.target.files[0]; if (!file) return;
    const reader = new FileReader(); reader.onload = ev => { try {
      parseTXT(ev.target.result);
      // 將 eq 與前置變數填回編輯區
      equationInput.value = assignments.map(a => `${a.var} = ${a.expr}`).join('\n') + (eqAssign ? `\neq = ${eqAssign.expr}` : '');
      buildParamControls(); rebuildCompiled(); scheduleUpdate('txt');
    } catch(err){ messageDiv.style.display='block'; messageDiv.textContent='TXT 解析錯誤：'+String(err); } };
    reader.readAsText(file);
  });

  document.getElementById('applyEquation').addEventListener('click', () => {
    try {
      const lines = equationInput.value.split(/\n+/); assignments=[]; eqAssign=null;
      lines.forEach(raw => { const line=raw.trim(); if(!line) return; const idx=line.indexOf('='); if(idx<0) return; const key=sanitizeName(line.slice(0,idx).trim()); const expr=line.slice(idx+1).trim(); if(key==='eq') eqAssign={var:key, expr:expr}; else assignments.push({var:key, expr:expr}); });
      rebuildCompiled(); scheduleUpdate('equation');
    } catch(err){ alert('方程式解析錯誤：'+String(err)); }
  });

  resetParamsBtn.addEventListener('click', () => { buildParamControls(); rebuildCompiled(); scheduleUpdate('reset'); });
  includeFuncQuantilesChk.addEventListener('change', () => { axesCache=null; scheduleUpdate('param'); });
  lockAxesChk.addEventListener('change', () => { axesCache=null; scheduleUpdate('param'); });

  // 初始尺寸與變數
  function init(){ updateControlsHeightVar(); resizeCanvas(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();

  // 範例按鈕
  document.getElementById('exampleA').addEventListener('click', () => {
    csvRows = parseCSV(exampleAData); parseTXT(exampleAEq);
    equationInput.value = assignments.map(a => `${a.var} = ${a.expr}`).join('\n') + `\neq = ${eqAssign.expr}`;
    populateXSelect(); buildFilters(); buildParamControls(); rebuildCompiled(); combosCache=null; axesCache=null; scheduleUpdate('exampleA');
  });
  document.getElementById('exampleB').addEventListener('click', () => {
    csvRows = parseCSV(exampleBData); parseTXT(exampleBEq);
    equationInput.value = assignments.map(a => `${a.var} = ${a.expr}`).join('\n') + `\neq = ${eqAssign.expr}`;
    populateXSelect(); buildFilters(); buildParamControls(); rebuildCompiled(); combosCache=null; axesCache=null; scheduleUpdate('exampleB');
  });
  </script>
</body>
</html>
